// Fix Prisma 7 client structure - create default.js that @prisma/client expects
const fs = require('fs');
const path = require('path');

const prismaClientPath = path.join(__dirname, '../.prisma/client');
const defaultJsPath = path.join(prismaClientPath, 'default.js');
const indexJsPath = path.join(prismaClientPath, 'index.js');

// Check if .prisma/client directory exists
if (!fs.existsSync(prismaClientPath)) {
  console.log('⚠️  Prisma Client directory not found at', prismaClientPath);
  console.log('   This is normal if Prisma hasn\'t generated yet. Skipping fix.');
  process.exit(0); // Don't fail, just skip
}

// Prisma 7 generates TypeScript files, but @prisma/client expects a JavaScript default.js
// The webpack alias in next.config.js should handle the import, but we still need default.js
// Create a default.js that re-exports everything from the client
// Since Next.js compiles TypeScript, we can create a JS file that will work at runtime

const defaultContent = `// This file is auto-generated by fix-prisma.js
// Prisma 7 generates TypeScript files, but @prisma/client expects this JS file
// At runtime, Next.js will have compiled the TypeScript, so we can require it
// The webpack alias ensures this resolves correctly during build

// Re-export everything from the client (which will be compiled by Next.js)
// We use a try-catch to handle both development and production scenarios
try {
  // Try to require the compiled client
  module.exports = require('./client');
} catch (e) {
  // If client.ts isn't compiled yet, create a proxy that will work at runtime
  // This is a workaround for the build-time module resolution
  const { PrismaClient } = require('@prisma/client/runtime/library');
  module.exports = { PrismaClient };
}
`;

fs.writeFileSync(defaultJsPath, defaultContent);
console.log('✅ Created .prisma/client/default.js');

